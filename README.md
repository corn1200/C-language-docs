# C-language-docs
## 목차
* [개요][1.]
  + [C 언어 탄생의 배경][1.1.]
* [C 프로그래밍][2.]
  + [소스 파일 작성][2.1.] 
  + [선행처리기 & 선행처리][2.2.]
  + [컴파일러 & 컴파일][2.3.]
  + [링커 & 링크][2.4.]
  + [실행 파일의 생성][2.5.]
* [C 언어 표준 입출력][3.]
  + [printf 함수][3.1.]
  + [scanf 함수][3.2.]
  + [서식 지정자][3.3.]
* [변수][4.]
  + [비트 & 바이트][4.1.]
  + [변수와 메모리 구조][4.2.]
  + [상수][4.3.]
  + [정수형 타입][4.4.]
  + [실수형 타입][4.5.]
  + [문자형 타입][4.6.]
  + [타입 변환][4.7.]
  + [묵시적 타입 변환][4.8.]
  + [명시적 타입 변환][4.9.]

[1.]: #1-개요
[1.1.]: #11-c-언어의-탄생-배경
[2.]: #2-c-프로그래밍
[2.1.]: #21-소스-파일-작성
[2.2.]: #22-선행처리기--선행처리
[2.3.]: #23-컴파일러--컴파일
[2.4.]: #24-링커--링크
[2.5.]: #25-실행-파일의-생성
[3.]: #3-c-언어-표준-입출력
[3.1.]: #31-printf-함수
[3.2.]: #32-scanf-함수
[3.3.]: #33-서식-지정자
[4.]: #4-변수
[4.1.]: #41-비트--바이트
[4.2.]: #42-변수와-메모리-구조
[4.3.]: #43-상수
[4.4.]: #44-정수형-타입
[4.5.]: #45-실수형-타입
[4.6.]: #46-문자형-타입
[4.7.]: #47-타입-변환
[4.8.]: #48-묵시적-타입-변환
[4.9.]: #49-명시적-타입-변환

# 1. 개요
C 언어는 현재 사용되고 있는 거의 모든 컴퓨터 시스템에서 사용할 수 있는 프로그래밍 언어이다.   
**현재 널리 사용되는 주요 운영체제의 커널은 대부분 C언어를 이용해 구현되어 있다.**   
이처럼 C 언어는 시스템 프로그래밍에 가장 잘 어울리지만, 응용 프로그래밍에도 많이 사용되는 프로그래밍 언어이다.

## 1.1. C 언어의 탄생 배경
C 언어 이전에 유닉스 운영체제는 어셈블리어라는 저급 언어를 사용했다.   
**어셈블리어는 특정 하드웨어에 종속적인 언어여서, 이 언어로 작성된 프로그램은 다른 하드웨어로 이식할 수 없었다.**   
**즉, 하나의 기능을 하는 프로그램을 CPU의 종류만큼 여러 번 작성해야만 했다.**  
따라서 이식성 좋고, 어셈블리어보다 쉬운 언어가 필요했으며 그래서 개발된 언어가 바로 C 언어이다.   

# 2. C 프로그래밍
프로그래밍이란 목적에 맞는 알고리즘으로부터 프로그래밍 언어를 사용하여 구체적인 프로그램을 작성하는 과정을 의미한다.   
이렇게 작성된 **프로그램은 먼저 실행 파일(executable file)로 변환되어야 실행할 수 있다.**

C 언어에서 실행 파일을 생성하는 순서는 다음 그림과 같다.
![C 언어 실행 파일을 생성하는 순서도](img/img_c_programming.png "C 언어에서 실행 파일을 생성하는 순서")
1. 소스 파일(source file)의 작성
2. 선행처리기(preprocessor)에 의한 선행처리
3. 컴파일러(compiler)에 의한 컴파일
4. 링커(linker)에 의한 링크
5. 실행 파일(executable file)의 생성

## 2.1. 소스 파일 작성
프로그래밍에서 가장 먼저 해야 할 작업은 바로 프로그램을 작성하는 것이다.  
**C 언어를 사용하여 문법에 맞게 논리적으로 작성된 프로그램을 원시 파일 또는 소스 파일이라고 한다.**   
C 언어를 통해 작성된 소스 파일의 확장자는 .c 가 된다.

## 2.2. 선행처리기 & 선행처리
**선행처리(preprocess)란 소스 파일 중에서도 선행처리 문자(#)로 시작하는 선행처리 지시문의 처리 작업을 의미한다.**   
이러한 선행처리 작업은 선행처리기(preprocessor)가 수행한다.  
**선행처리기는 코드를 생성하는 것이 아닌, 컴파일하기 전 컴파일러가 작업하기 좋도록 소스를 재구성해주는 역할만을 한다.**

선행처리에 대한 더 자세한 사항은 C 언어 선행처리기 수업에서 확인할 수 있다.

## 2.3. 컴파일러 & 컴파일
컴퓨터는 0과 1로 이루어진 이진수로 작성된 기계어만을 이해할 수 있다.   
소스 파일은 개발자에 의해 C 언어로 작성되므로, 컴퓨터는 그것을 바로 이해할 수 없다.   
따라서 **소스 파일을 컴퓨터가 알아볼 수 있는 기계어로 변환시켜야 하는데, 그 작업을 컴파일(compile)이라고 한다.**

컴파일은 컴파일러에 의해 수행되며, **컴파일이 끝나 기계어로 변환된 파일을 오브젝트 파일(object file)이라고 한다.**   
이러한 오브젝트 파일의 확장자는 .o 나 .obj 가 된다.

## 2.4. 링커 & 링크
**컴파일러에 의해 생성된 오브젝트 파일은 운영체제와의 인터페이스를 담당하는 시동 코드(start-up code)를 가지고 있지 않다.**  
또한, 대부분의 C 프로그램에서 사용하는 C 표준 라이브러리 파일도 포함되어 있지 않다.   
이때 **하나 이상의 오브젝트 파일과 라이브러리 파일, 시동 코드 등을 합쳐 하나의 파일로 만드는 작업을 링크(link)라고 한다.**

링크는 링커(linker)에 의해 수행되며, **링크가 끝나면 하나의 새로운 실행 파일이나 라이브러리 파일이 생성된다.**   
이처럼 여러 개의 소스 파일을 작성하여 최종적으로 링크를 통해 하나의 실행 파일로 만드는 것을 **분할 컴파일**이라고 한다.

## 2.5. 실행 파일의 생성
**소스 파일은 선행처리기, 컴파일러 그리고 링커에 의해 위와 같은 과정을 거쳐 실행 파일로 변환된다.**   
최근 사용되는 개발 툴은 대부분 위에서 소개한 선행처리기, 컴파일러, 링커를 모두 내장하고 있으므로, 소스 파일에서 한 번에 실행 파일을 생성해 준다.   
이렇게 생성된 실행 파일의 확장자는 .exe 가 된다.

# 3. C 언어 표준 입출력
사용자가 프로그램과 대화하기 위해 사용하는 함수를 입출력 함수 또는 I/O 함수라고 한다.   
printf() 함수와 scanf() 함수는 C 언어 표준 입출력 함수 중에서도 가장 많이 사용되는 대표적인 입출력 함수이다.

## 3.1. printf 함수
printf() 함수의 원형은 다음과 같다.
```c
#include <stdio.h>
int print(const char * restrict format, ...);
```
printf() 함수의 f는 formatted의 약자이며, 서식화된 출력을 지원한다는 의미이다.   
이 함수는 출력할 데이터를 어떤 서식에 맞춰 출력할지 서식 지정자(format specifier)를 통해 직접 지정할 수 있다.
```c
printf("int 값: %d", 10);
```
```
int 값: 10
```
위의 코드에서는 int형 데이터를 나타내기 위해서 '%d'라는 서식 지정자를 사용했다.

## 3.2. scanf 함수
scanf() 함수의 원형은 다음과 같다.
```c
#include <stdio.h>
int scanf(const char * restrict format, ...);
```
scanf() 함수의 f는 formatted의 약자이며, 서식화된 입력을 받는다는 의미이다.  
이 함수는 입력받은 데이터를 어떤 서식으로 변환할지 서식 지정자(format specifier)를 통해 직접 지정할 수 있다.
```c
#include <stdio.h>

int main(void)
{
  int num1, num2;

  printf("num1 : ");
  scanf("%d", &num1);
  printf("num2 : ");
  scanf("%d", &num2);  

  printf("num1 + num2 = %d", num1 + num2);
  return 0;
}
```
```
num1 : 10
num2 : 20
num1 + num2 = 30
```
**C 언어에서 데이터를입력 받으려면 입력받고자 하는 데이터의 타입에 해당하는 크기의 메모리를 우선 할당받아야 한다.**   
**이처럼 데이터를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 변수(variable)라고 한다.**

## 3.3. 서식 지정자
C 언어에서 사용되는 대표적인 서식 지정자는 다음과 같다.

|서식 지정자|출력 데이터 형태|
|------|---|
|%c|하나의 문자|
|%s|문자열|
|%d|부호 있는 10진 정수|
|%i|부호 있는 10진 정수 (%d와 동일)|
|%f|고정 소수점으로 표현한 실수 (소수점 이하 6자리까지 표현)|
|%o|부호 없는 8진 정수|
|%u|부호 없는 10진 정수|
|%x|부호 없는 16진 정수 (소문자 사용)|
|%X|부호 없는 16진 정수 (대문자 사용)|
|%e|부동 소수점으로 표현한 실수 (e-표기법)|
|%E|부동 소수점으로 표현한 실수 (E-표기법)|
|%g|값에 따라 %f나 %e를 사용함.|
|%G|값에 따라 %f나 %E를 사용함.|
|%%|퍼센트(%) 기호 출력|

# 4. 변수
**변수(variable)란 데이터(data)를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미한다.**   
즉, 변수란 데이터(data)를 저장할 수 있는 메모리 공간을 의미하여, 이렇게 저정된 값은 변경될 수 있다.

데이터가 저장된 메모리의 주소를 저장하고 처리하는 포인터 변수가 있다.   
관련된 정보를 한 번에 묶어서 처리하는 사용자 정의 구조체 변수도 있다.

## 4.1. 비트 & 바이트
컴퓨터는 모든 데이터를 2진수로 표현하고 처리한다.   
**비트(bit)란 컴퓨터가 데이터를 처리하기 위해 사용하는 데이터의 최소 단위이다.**   
이러한 비트에는 2진수의 값(0과 1)을 단 하나만 저장할 수 있다.   
**바이트(byte)란 위와 같은 비트가 8개 모여서 구성되며, 한 문자를 표현할 수 있는 최소 단위이다.**

## 4.2. 변수와 메모리 구조
변수는 기본적으로 메모리의 주소(address)를 기억하는 역할을 한다.   
**메모리 주소란 물리적인 메모리 공간을 서로 구분하기 위해 사용되는 일종의 식별자이다.**   
즉, 메모리 주소란 메모리 공간에서의 정확한 위치를 식별하기 위한 고유 주소를 의미한다.

변수를 참조할 때는 메모리의 주소를 참조하는 것이 아닌, 해당 주소에 저장된 데이터를 참조하게 된다.   
따라서 변수는 데이터가 저장된 메모리의 주소뿐만 아니라, 저장된 데이터의 길이와 형태에 관한 정보도 같이 기억해야 한다.

다음 그림은 메모리 상에 변수가 어떤 식으로 저장되는지를 보여준다.
![메모리에 저장된 변수](/img/img_c_variable.png)
위의 그림처럼 하나의 메모리 공간에는 8개의 비트로 이루어진 1바이트의 데이터가 저장된다.   
따라서 메모리의 주소 또한 1바이트씩 증가되며, 낮은 주소부터 차례대로 데이터가 저장된다.   
위의 그림에서 변수의 길이가 총 4개의 메모리 공간을 포함하므로, 해당 변수에는 4바이트의 데이터가 저장되어 있다.

이때 변수의 이름은 첫 번째 메모리 주소인 0x10만을 가리키게 된다.   
따라서 변수의 길이가 4이며, 변수가 어떤 형태로 구성되는지도 알아야만 해당 변수에서 데이터를 올바르게 참조할 수 있다.

## 4.3. 상수
상수(constant)란 변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간을 의미한다.  
하지만 **상수가 변수와 다른 점은 프로그램이 실행되는 동안 상수에 저장된 데이터는 변경할 수 없다는 점이다.**

상수는 변수와 마찬가지로 이름을 가지고 있다.   
**이러한 상수는 반드시 선언과 동시에 초기화되어야 한다.**   
상수는 const 키워드를 사용하거나, 매크로를 이용하여 선언할 수 있다.
```c
const int MAX = 10; // const 키워드를 이용한 심볼릭 상수
#define MAX 10; // #define 선행처리 지시자를 이용한 매크로 상수
```

## 4.4. 정수형 타입
C 언어에서 정수란 부호를 가지고 있고, 소수 부분이 없는 수를 의미한다.

정수형 데이터에 unsigned 키워드를 추가하면, 부호를 나타내는 최상위 비트(MSB, Most Significant Bit)까지도 크기를 나타내는 데 사용할 수 있다.   
이러한 unsigned 정수는 음수를 표현할 수는 없게 되지만, 0을 포함한 양의 정수는 두 배 더 많이 표현할 수 있게 된다.   
음의 정수까지도 표현할 수 있는 signed 키워드는 모든 타입에서 기본적으로 생략하여 사용할 수 있다.

> 최상위 비트(MSB, Most Significant Bit)란 1바이트를 구성하는 8개의 비트 중 최고값을 갖는 비트를 의미한다.

다음 표는 각각의 정수 타입에 따른 메모리의 크기 및 데이터의 표현 범위를 나타낸다.

|정수형 타입|할당되는 메모리의 크기|데이터의 표현 범위|
|------|---|---|
|(signed) short|2 바이트|-32,768~32,767|
|unsigned short|2 바이트|-0 ~ 65,535|
|(signed) int|4바이트|-2,147,483,648 ~ 2,147,483,647|
|unsigned int|4바이트|-0 ~ 4,294,967,296|
|(signed) long|4바이트|-2,147,483,648 ~ 2,147,483,647|
|unsigned long|4바이트|-0 ~ 4,294,967,296|

정수형 데이터의 타입을 결정할 때에는 반드시 자신이 사용하고자 하는 데이터의 최대 크기를 고려해야 한다.   
**해당 타입이 표현할 수 있는 범위를 벗어난 데이터를 저장하면, 오버플로우가 발생해 전혀 다른 값이 저장될 수 있기 때문이다.**

오버플로우(overflow)란 해당 타입이 표현할 수 있는 최대 범위보다 큰 수를 저장할 때 발생하는 현상을 가리킨다.   
오버플로우가 발생하면 최상위 비트(MSB)를 벗어난 데이터가 인접 비트를 덮어쓰므로, 잘못된 결과를 얻을 수 있다.   
또한, 언더플로우(underflow)란 해당 타입이 표현할 수 있는 최소 범위보다 작은 수를 저장할 때 발생하는 현상을 가리킨다.

## 4.5. 실수형 타입
C 언어에서 실수란 소수부나 지수가 있는 수를 가리키며, 정수보다 훨씬 더 넓은 표현 범위를 가진다.   
하지만 **컴퓨터에서 실수를 표현하는 방식은 반드시 오차가 발생하는 기술적 한계를 지닌다.**   

|실수형 타입|할당되는 메모리의 크기|데이터의 표현 범위|
|------|---|---|
|float|4 바이트|(3.4 * 10^-38) ~ (3.4 * 10^38)|
|double|8 바이트|(1.7 * 10^-308) ~ (1.7 * 10^308)|
|long double|double형과 동일함.|double형과 동일함.|

실수형 데이터의 타입을 결정할 때는 표현 범위 이외에도 유효 자릿수를 반드시 고려해야 한다.

|실수형 타입|지수의 길이|가수의 길이|유효 자릿수|
|------|---|---|---|
|float|8비트|23비트|소수 부분 6자리까지 오차없이 표현할 수 있음.|
|double|11비트|52비트|소수 부분 15자리까지 오차없이 표현할 수 있음.|

## 4.6. 문자형 타입
C 언어에서 문자형 데이터란 문자 하나를 표현할 수 있는 타입을 의미한다.   
컴퓨터는 2진수밖에 인식하지 못하므로, 문자도 숫자로 표현해야 컴퓨터가 인식할 수 있다.   
따라서 어떤 문자를 어떤 숫자에 대응시킬 것인가에 대한 약속이 필요해진다.

이러한 약속 중에서 가장 많이 사용되는 것이 바로 아스키코드(ASCII)이다.   
아스키코드(ASCII)는 영문 대소문자를 사용하는 7비트의 문자 인코딩 방식이다.   
아스키코드는 문자를 7비트로 표현하므로, 총 128개의 문자를 표현할 수 있다.

아스키코드의 구성은 다음과 같다.

- 출력할 수 없는 33개의 문자
- 출력할 수 있는 52개의 영문 대소문자, 10개의 숫자, 32개의 특수 문자와 1개의 공백 문자

|문자형 타입|할당되는 메모리의 크기|데이터의 표현 범위|
|------|---|---|
|(signed) char|1 바이트|2^7 ~ 2^-7|
|unsigned char|2 바이트|0 ~ 2^-8|

## 4.7. 타입 변환
C 언어에서 다른 타입끼리의 연산은 우선 피연산자들을 모두 같은 타입으로 만든 후에 수행된다.   
이처럼 하나의 타입을 다른 타입으로 바꾸는 행위를 타입 변환(type conversion)이라고 한다.   

표현 범위가 좁은 타입에서 표현 범위가 더 넓은 타입으로의 타입 변환은 큰 문제가 되지 않는다.   
하지만 반대의 경우인 **표현 범위가 좁은 타입으로의 타입 변환에서는 데이터의 손상이 발생한다.**

타입 변환은 크게 다음과 같이 두 가지 방식으로 나눌 수 있다.

1. 묵시적 타입 변환(자동 타입 변환)
2. 명시적 타입 변환(강제 타입 변환)

## 4.8. 묵시적 타입 변환
묵시적 타입 변환(implicit type conversion)은 대입 연산이나 산술 연산에서 C 컴파일러가 자동으로 실행해주는 타입 변환을 가리킨다.   
C 언어에서는 대입 연산 시 연산자의 오른쪽에 존재하는 데이터의 타입이 연산자의 왼쪽에 존재하는 데이터의 타입으로 묵시적 타입 변환이 진행된다.   
또한, 산술 연산에서는 데이터의 손실이 최소화되는 방향으로 묵시적 타입 변환이 진행된다.

다음 코드는 대입 연산에서 일어나는 묵시적 타입 변환을 보여준다.
```c
char ch = 200;
int intNum = 3.14;
double doubleNum = 5;

printf("ch : %d\n", ch);
printf("intNum : %d\n", intNum);
printf("doubleNum : %f\n", doubleNum);
```
```
ch : -56
intNum : 3
doubleNum : 5.000000
```
위의 코드에서는 char형 변수에 char형 변수가 표현할 수 있는 범위를 넘는 데이터를 저장한다.   
따라서 전달된 데이터의 상위 비트가 자동으로 삭제되어 데이터의 손실이 발생한다.   
또한, int형 변수에 실수를 저장했기 때문에 소수 부분이 자동으로 삭제되어 데이터의 손실이 발생한다.   
하지만 double형 변수에 int형 데이터를 저장하는 것은 데이터가 double형으로 자동 타입 변환되지만, 데이터의 손실은 발생하지 않는다.

다음 코드는 산술 연산에서 일어나는 묵시적 타입 변환을 보여준다.
```c
double calc1 = 5 + 3.14;
double calc2 = 5.0f + 3.14;

printf("calc1 : %f\n", calc1);
printf("calc2 : %f\n", calc2);
```
```
calc1 : 8.140000
calc2 : 8.140000
```
위의 코드에서 첫 번째 연산은 int형 데이터와 double형 데이터의 산술 연산이다.   
따라서 데이터의 손실이 최소화되도록 int형 데이터가 double형 데이터로 자동 타입 변환된다.  
두 번째 연산은 float형 데이터와 double형 데이터의 산술 연산이다.  
위와 마찬가지로 데이터의 손실이 최소화되도록 float형 데이터가 double형 데이터로 자동 타입 변환된다.

이렇게 **컴파일러가 자동으로 수행하는 타입 변환은 언제나 데이터의 손실이 최소화되는 방향으로 이루어진다.**  
따라서 C 컴파일러는 다음과 같은 순서대로 자동 타입 변환을 수행하게 된다.

char 형 -> short 형 -> int 형 -> float 형 -> double 형 -> long double 형

## 4.9. 명시적 타입 변환
명시적 타입 변환은 사용자가 타입 캐스트(type cast) 연산자를 사용하여 강제적으로 수행하는 타입 변환을 가리킨다.  
변환하고자 하는 데이터의 앞에 괄호(())를 추가하고, 그 안에 변환할 타입을 적으면 된다. 
C 언어에서는 이 괄호(())를 타입 캐스트(type cast) 연산자라고 한다.  

다음 코드는 명시적 타입 변환을 보여준다.
```c
int num1 = 1;
int num2 = 4;

double calc1 = num1 / num2;
double calc2 = (double) num1 / num2;

printf("calc1 : %f\n", calc1);
printf("calc2 : %f\n", calc2);
```
```
calc1 : 0.000000
calc2 : 0.250000
```
위의 코드에서 첫 번째 연산의 결괏값은 0.000000으로 출력된다.  
그 이유는 산술 연산에 대한 결괏값의 타입은 피연산자의 타입과 언제나 일치하기 때문이다.  
즉 int형 데이터끼리의 산술 연산에 대한 결괏값은 언제나 int형 데이터로 나온다. 
따라서 두 번째 연산에서처럼 하나의 피연산자를 명시적으로 double형으로 지정해야만 정확한 결괏값을 얻을 수 있다.