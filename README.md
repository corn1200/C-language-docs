# C-language-docs
## 목차
* [개요][1.]
  + [C 언어 탄생의 배경][1.1.]
* [C 프로그래밍][2.]
  + [소스 파일 작성][2.1.] 
  + [선행처리기 & 선행처리][2.2.]
  + [컴파일러 & 컴파일][2.3.]
  + [링커 & 링크][2.4.]
  + [실행 파일의 생성][2.5.]
* [C 언어 표준 입출력][3.]
  + [printf 함수][3.1.]
  + [scanf 함수][3.2.]
  + [서식 지정자][3.3.]
* [변수][4.]
  + [비트 & 바이트][4.1.]
  + [변수와 메모리 구조][4.2.]
  + [상수][4.3.]
  + [정수형 타입][4.4.]
  + [실수형 타입][4.5.]
  + [문자형 타입][4.6.]
  + [타입 변환][4.7.]
  + [묵시적 타입 변환][4.8.]
  + [명시적 타입 변환][4.9.]
* [5. 연산자][5.]
  + [5.1. 산술 연산자][5.1.]
  + [5.2. 대입 연산자][5.2.]
  + [5.3. 증감 연산자][5.3.]
  + [5.4. 비교 연산자][5.4.]
  + [5.5. 논리 연산자][5.5.]
* [6. 함수][6.]
  + [6.1. 함수의 원형 선언][6.1.]
  + [6.2. 변수의 유효 범위][6.2.]
  + [6.3. 재귀 호출][6.3.]

[1.]: #1-개요
[1.1.]: #11-c-언어의-탄생-배경
[2.]: #2-c-프로그래밍
[2.1.]: #21-소스-파일-작성
[2.2.]: #22-선행처리기--선행처리
[2.3.]: #23-컴파일러--컴파일
[2.4.]: #24-링커--링크
[2.5.]: #25-실행-파일의-생성
[3.]: #3-c-언어-표준-입출력
[3.1.]: #31-printf-함수
[3.2.]: #32-scanf-함수
[3.3.]: #33-서식-지정자
[4.]: #4-변수
[4.1.]: #41-비트--바이트
[4.2.]: #42-변수와-메모리-구조
[4.3.]: #43-상수
[4.4.]: #44-정수형-타입
[4.5.]: #45-실수형-타입
[4.6.]: #46-문자형-타입
[4.7.]: #47-타입-변환
[4.8.]: #48-묵시적-타입-변환
[4.9.]: #49-명시적-타입-변환
[5.]: #5-연산자
[5.1.]: #51-산술-연산자
[5.2.]: #52-대입-연산자
[5.3.]: #53-증감-연산자
[5.4.]: #54-비교-연산자
[5.5.]: #55-논리-연산자
[6.]: #6-함수
[6.1.]: #61-함수의-원형-선언
[6.2.]: #62-변수의-유효-범위
[6.3.]: #63-재귀-호출

# 1. 개요
C 언어는 현재 사용되고 있는 거의 모든 컴퓨터 시스템에서 사용할 수 있는 프로그래밍 언어이다.   
**현재 널리 사용되는 주요 운영체제의 커널은 대부분 C언어를 이용해 구현되어 있다.**   
이처럼 C 언어는 시스템 프로그래밍에 가장 잘 어울리지만, 응용 프로그래밍에도 많이 사용되는 프로그래밍 언어이다.

## 1.1. C 언어의 탄생 배경
C 언어 이전에 유닉스 운영체제는 어셈블리어라는 저급 언어를 사용했다.   
**어셈블리어는 특정 하드웨어에 종속적인 언어여서, 이 언어로 작성된 프로그램은 다른 하드웨어로 이식할 수 없었다.**   
**즉, 하나의 기능을 하는 프로그램을 CPU의 종류만큼 여러 번 작성해야만 했다.**  
따라서 이식성 좋고, 어셈블리어보다 쉬운 언어가 필요했으며 그래서 개발된 언어가 바로 C 언어이다.   

# 2. C 프로그래밍
프로그래밍이란 목적에 맞는 알고리즘으로부터 프로그래밍 언어를 사용하여 구체적인 프로그램을 작성하는 과정을 의미한다.   
이렇게 작성된 **프로그램은 먼저 실행 파일(executable file)로 변환되어야 실행할 수 있다.**

C 언어에서 실행 파일을 생성하는 순서는 다음 그림과 같다.
![C 언어 실행 파일을 생성하는 순서도](img/img_c_programming.png "C 언어에서 실행 파일을 생성하는 순서")
1. 소스 파일(source file)의 작성
2. 선행처리기(preprocessor)에 의한 선행처리
3. 컴파일러(compiler)에 의한 컴파일
4. 링커(linker)에 의한 링크
5. 실행 파일(executable file)의 생성

## 2.1. 소스 파일 작성
프로그래밍에서 가장 먼저 해야 할 작업은 바로 프로그램을 작성하는 것이다.  
**C 언어를 사용하여 문법에 맞게 논리적으로 작성된 프로그램을 원시 파일 또는 소스 파일이라고 한다.**   
C 언어를 통해 작성된 소스 파일의 확장자는 .c 가 된다.

## 2.2. 선행처리기 & 선행처리
**선행처리(preprocess)란 소스 파일 중에서도 선행처리 문자(#)로 시작하는 선행처리 지시문의 처리 작업을 의미한다.**   
이러한 선행처리 작업은 선행처리기(preprocessor)가 수행한다.  
**선행처리기는 코드를 생성하는 것이 아닌, 컴파일하기 전 컴파일러가 작업하기 좋도록 소스를 재구성해주는 역할만을 한다.**

선행처리에 대한 더 자세한 사항은 C 언어 선행처리기 수업에서 확인할 수 있다.

## 2.3. 컴파일러 & 컴파일
컴퓨터는 0과 1로 이루어진 이진수로 작성된 기계어만을 이해할 수 있다.   
소스 파일은 개발자에 의해 C 언어로 작성되므로, 컴퓨터는 그것을 바로 이해할 수 없다.   
따라서 **소스 파일을 컴퓨터가 알아볼 수 있는 기계어로 변환시켜야 하는데, 그 작업을 컴파일(compile)이라고 한다.**

컴파일은 컴파일러에 의해 수행되며, **컴파일이 끝나 기계어로 변환된 파일을 오브젝트 파일(object file)이라고 한다.**   
이러한 오브젝트 파일의 확장자는 .o 나 .obj 가 된다.

## 2.4. 링커 & 링크
**컴파일러에 의해 생성된 오브젝트 파일은 운영체제와의 인터페이스를 담당하는 시동 코드(start-up code)를 가지고 있지 않다.**  
또한, 대부분의 C 프로그램에서 사용하는 C 표준 라이브러리 파일도 포함되어 있지 않다.   
이때 **하나 이상의 오브젝트 파일과 라이브러리 파일, 시동 코드 등을 합쳐 하나의 파일로 만드는 작업을 링크(link)라고 한다.**

링크는 링커(linker)에 의해 수행되며, **링크가 끝나면 하나의 새로운 실행 파일이나 라이브러리 파일이 생성된다.**   
이처럼 여러 개의 소스 파일을 작성하여 최종적으로 링크를 통해 하나의 실행 파일로 만드는 것을 **분할 컴파일**이라고 한다.

## 2.5. 실행 파일의 생성
**소스 파일은 선행처리기, 컴파일러 그리고 링커에 의해 위와 같은 과정을 거쳐 실행 파일로 변환된다.**   
최근 사용되는 개발 툴은 대부분 위에서 소개한 선행처리기, 컴파일러, 링커를 모두 내장하고 있으므로, 소스 파일에서 한 번에 실행 파일을 생성해 준다.   
이렇게 생성된 실행 파일의 확장자는 .exe 가 된다.

# 3. C 언어 표준 입출력
사용자가 프로그램과 대화하기 위해 사용하는 함수를 입출력 함수 또는 I/O 함수라고 한다.   
printf() 함수와 scanf() 함수는 C 언어 표준 입출력 함수 중에서도 가장 많이 사용되는 대표적인 입출력 함수이다.

## 3.1. printf 함수
printf() 함수의 원형은 다음과 같다.
```c
#include <stdio.h>
int print(const char * restrict format, ...);
```
printf() 함수의 f는 formatted의 약자이며, 서식화된 출력을 지원한다는 의미이다.   
이 함수는 출력할 데이터를 어떤 서식에 맞춰 출력할지 서식 지정자(format specifier)를 통해 직접 지정할 수 있다.
```c
printf("int 값: %d", 10);
```
```
int 값: 10
```
위의 코드에서는 int형 데이터를 나타내기 위해서 '%d'라는 서식 지정자를 사용했다.

## 3.2. scanf 함수
scanf() 함수의 원형은 다음과 같다.
```c
#include <stdio.h>
int scanf(const char * restrict format, ...);
```
scanf() 함수의 f는 formatted의 약자이며, 서식화된 입력을 받는다는 의미이다.  
이 함수는 입력받은 데이터를 어떤 서식으로 변환할지 서식 지정자(format specifier)를 통해 직접 지정할 수 있다.
```c
#include <stdio.h>

int main(void)
{
  int num1, num2;

  printf("num1 : ");
  scanf("%d", &num1);
  printf("num2 : ");
  scanf("%d", &num2);  

  printf("num1 + num2 = %d", num1 + num2);
  return 0;
}
```
```
num1 : 10
num2 : 20
num1 + num2 = 30
```
**C 언어에서 데이터를입력 받으려면 입력받고자 하는 데이터의 타입에 해당하는 크기의 메모리를 우선 할당받아야 한다.**   
**이처럼 데이터를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 변수(variable)라고 한다.**

## 3.3. 서식 지정자
C 언어에서 사용되는 대표적인 서식 지정자는 다음과 같다.

|서식 지정자|출력 데이터 형태|
|------|---|
|%c|하나의 문자|
|%s|문자열|
|%d|부호 있는 10진 정수|
|%i|부호 있는 10진 정수 (%d와 동일)|
|%f|고정 소수점으로 표현한 실수 (소수점 이하 6자리까지 표현)|
|%o|부호 없는 8진 정수|
|%u|부호 없는 10진 정수|
|%x|부호 없는 16진 정수 (소문자 사용)|
|%X|부호 없는 16진 정수 (대문자 사용)|
|%e|부동 소수점으로 표현한 실수 (e-표기법)|
|%E|부동 소수점으로 표현한 실수 (E-표기법)|
|%g|값에 따라 %f나 %e를 사용함.|
|%G|값에 따라 %f나 %E를 사용함.|
|%%|퍼센트(%) 기호 출력|

# 4. 변수
**변수(variable)란 데이터(data)를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미한다.**   
즉, 변수란 데이터(data)를 저장할 수 있는 메모리 공간을 의미하여, 이렇게 저정된 값은 변경될 수 있다.

데이터가 저장된 메모리의 주소를 저장하고 처리하는 포인터 변수가 있다.   
관련된 정보를 한 번에 묶어서 처리하는 사용자 정의 구조체 변수도 있다.

## 4.1. 비트 & 바이트
컴퓨터는 모든 데이터를 2진수로 표현하고 처리한다.   
**비트(bit)란 컴퓨터가 데이터를 처리하기 위해 사용하는 데이터의 최소 단위이다.**   
이러한 비트에는 2진수의 값(0과 1)을 단 하나만 저장할 수 있다.   
**바이트(byte)란 위와 같은 비트가 8개 모여서 구성되며, 한 문자를 표현할 수 있는 최소 단위이다.**

## 4.2. 변수와 메모리 구조
변수는 기본적으로 메모리의 주소(address)를 기억하는 역할을 한다.   
**메모리 주소란 물리적인 메모리 공간을 서로 구분하기 위해 사용되는 일종의 식별자이다.**   
즉, 메모리 주소란 메모리 공간에서의 정확한 위치를 식별하기 위한 고유 주소를 의미한다.

변수를 참조할 때는 메모리의 주소를 참조하는 것이 아닌, 해당 주소에 저장된 데이터를 참조하게 된다.   
따라서 변수는 데이터가 저장된 메모리의 주소뿐만 아니라, 저장된 데이터의 길이와 형태에 관한 정보도 같이 기억해야 한다.

다음 그림은 메모리 상에 변수가 어떤 식으로 저장되는지를 보여준다.
![메모리에 저장된 변수](/img/img_c_variable.png)
위의 그림처럼 하나의 메모리 공간에는 8개의 비트로 이루어진 1바이트의 데이터가 저장된다.   
따라서 메모리의 주소 또한 1바이트씩 증가되며, 낮은 주소부터 차례대로 데이터가 저장된다.   
위의 그림에서 변수의 길이가 총 4개의 메모리 공간을 포함하므로, 해당 변수에는 4바이트의 데이터가 저장되어 있다.

이때 변수의 이름은 첫 번째 메모리 주소인 0x10만을 가리키게 된다.   
따라서 변수의 길이가 4이며, 변수가 어떤 형태로 구성되는지도 알아야만 해당 변수에서 데이터를 올바르게 참조할 수 있다.

## 4.3. 상수
상수(constant)란 변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간을 의미한다.  
하지만 **상수가 변수와 다른 점은 프로그램이 실행되는 동안 상수에 저장된 데이터는 변경할 수 없다는 점이다.**

상수는 변수와 마찬가지로 이름을 가지고 있다.   
**이러한 상수는 반드시 선언과 동시에 초기화되어야 한다.**   
상수는 const 키워드를 사용하거나, 매크로를 이용하여 선언할 수 있다.
```c
const int MAX = 10; // const 키워드를 이용한 심볼릭 상수
#define MAX 10; // #define 선행처리 지시자를 이용한 매크로 상수
```

## 4.4. 정수형 타입
C 언어에서 정수란 부호를 가지고 있고, 소수 부분이 없는 수를 의미한다.

정수형 데이터에 unsigned 키워드를 추가하면, 부호를 나타내는 최상위 비트(MSB, Most Significant Bit)까지도 크기를 나타내는 데 사용할 수 있다.   
이러한 unsigned 정수는 음수를 표현할 수는 없게 되지만, 0을 포함한 양의 정수는 두 배 더 많이 표현할 수 있게 된다.   
음의 정수까지도 표현할 수 있는 signed 키워드는 모든 타입에서 기본적으로 생략하여 사용할 수 있다.

> 최상위 비트(MSB, Most Significant Bit)란 1바이트를 구성하는 8개의 비트 중 최고값을 갖는 비트를 의미한다.

다음 표는 각각의 정수 타입에 따른 메모리의 크기 및 데이터의 표현 범위를 나타낸다.

|정수형 타입|할당되는 메모리의 크기|데이터의 표현 범위|
|------|---|---|
|(signed) short|2 바이트|-32,768~32,767|
|unsigned short|2 바이트|-0 ~ 65,535|
|(signed) int|4바이트|-2,147,483,648 ~ 2,147,483,647|
|unsigned int|4바이트|-0 ~ 4,294,967,296|
|(signed) long|4바이트|-2,147,483,648 ~ 2,147,483,647|
|unsigned long|4바이트|-0 ~ 4,294,967,296|

정수형 데이터의 타입을 결정할 때에는 반드시 자신이 사용하고자 하는 데이터의 최대 크기를 고려해야 한다.   
**해당 타입이 표현할 수 있는 범위를 벗어난 데이터를 저장하면, 오버플로우가 발생해 전혀 다른 값이 저장될 수 있기 때문이다.**

오버플로우(overflow)란 해당 타입이 표현할 수 있는 최대 범위보다 큰 수를 저장할 때 발생하는 현상을 가리킨다.   
오버플로우가 발생하면 최상위 비트(MSB)를 벗어난 데이터가 인접 비트를 덮어쓰므로, 잘못된 결과를 얻을 수 있다.   
또한, 언더플로우(underflow)란 해당 타입이 표현할 수 있는 최소 범위보다 작은 수를 저장할 때 발생하는 현상을 가리킨다.

## 4.5. 실수형 타입
C 언어에서 실수란 소수부나 지수가 있는 수를 가리키며, 정수보다 훨씬 더 넓은 표현 범위를 가진다.   
하지만 **컴퓨터에서 실수를 표현하는 방식은 반드시 오차가 발생하는 기술적 한계를 지닌다.**   

|실수형 타입|할당되는 메모리의 크기|데이터의 표현 범위|
|------|---|---|
|float|4 바이트|(3.4 * 10^-38) ~ (3.4 * 10^38)|
|double|8 바이트|(1.7 * 10^-308) ~ (1.7 * 10^308)|
|long double|double형과 동일함.|double형과 동일함.|

실수형 데이터의 타입을 결정할 때는 표현 범위 이외에도 유효 자릿수를 반드시 고려해야 한다.

|실수형 타입|지수의 길이|가수의 길이|유효 자릿수|
|------|---|---|---|
|float|8비트|23비트|소수 부분 6자리까지 오차없이 표현할 수 있음.|
|double|11비트|52비트|소수 부분 15자리까지 오차없이 표현할 수 있음.|

## 4.6. 문자형 타입
C 언어에서 문자형 데이터란 문자 하나를 표현할 수 있는 타입을 의미한다.   
컴퓨터는 2진수밖에 인식하지 못하므로, 문자도 숫자로 표현해야 컴퓨터가 인식할 수 있다.   
따라서 어떤 문자를 어떤 숫자에 대응시킬 것인가에 대한 약속이 필요해진다.

이러한 약속 중에서 가장 많이 사용되는 것이 바로 아스키코드(ASCII)이다.   
아스키코드(ASCII)는 영문 대소문자를 사용하는 7비트의 문자 인코딩 방식이다.   
아스키코드는 문자를 7비트로 표현하므로, 총 128개의 문자를 표현할 수 있다.

아스키코드의 구성은 다음과 같다.

- 출력할 수 없는 33개의 문자
- 출력할 수 있는 52개의 영문 대소문자, 10개의 숫자, 32개의 특수 문자와 1개의 공백 문자

|문자형 타입|할당되는 메모리의 크기|데이터의 표현 범위|
|------|---|---|
|(signed) char|1 바이트|2^7 ~ 2^-7|
|unsigned char|2 바이트|0 ~ 2^-8|

## 4.7. 타입 변환
C 언어에서 다른 타입끼리의 연산은 우선 피연산자들을 모두 같은 타입으로 만든 후에 수행된다.   
이처럼 하나의 타입을 다른 타입으로 바꾸는 행위를 타입 변환(type conversion)이라고 한다.   

표현 범위가 좁은 타입에서 표현 범위가 더 넓은 타입으로의 타입 변환은 큰 문제가 되지 않는다.   
하지만 반대의 경우인 **표현 범위가 좁은 타입으로의 타입 변환에서는 데이터의 손상이 발생한다.**

타입 변환은 크게 다음과 같이 두 가지 방식으로 나눌 수 있다.

1. 묵시적 타입 변환(자동 타입 변환)
2. 명시적 타입 변환(강제 타입 변환)

## 4.8. 묵시적 타입 변환
묵시적 타입 변환(implicit type conversion)은 대입 연산이나 산술 연산에서 C 컴파일러가 자동으로 실행해주는 타입 변환을 가리킨다.   
C 언어에서는 대입 연산 시 연산자의 오른쪽에 존재하는 데이터의 타입이 연산자의 왼쪽에 존재하는 데이터의 타입으로 묵시적 타입 변환이 진행된다.   
또한, 산술 연산에서는 데이터의 손실이 최소화되는 방향으로 묵시적 타입 변환이 진행된다.

다음 코드는 대입 연산에서 일어나는 묵시적 타입 변환을 보여준다.
```c
char ch = 200;
int intNum = 3.14;
double doubleNum = 5;

printf("ch : %d\n", ch);
printf("intNum : %d\n", intNum);
printf("doubleNum : %f\n", doubleNum);
```
```
ch : -56
intNum : 3
doubleNum : 5.000000
```
위의 코드에서는 char형 변수에 char형 변수가 표현할 수 있는 범위를 넘는 데이터를 저장한다.   
따라서 전달된 데이터의 상위 비트가 자동으로 삭제되어 데이터의 손실이 발생한다.   
또한, int형 변수에 실수를 저장했기 때문에 소수 부분이 자동으로 삭제되어 데이터의 손실이 발생한다.   
하지만 double형 변수에 int형 데이터를 저장하는 것은 데이터가 double형으로 자동 타입 변환되지만, 데이터의 손실은 발생하지 않는다.

다음 코드는 산술 연산에서 일어나는 묵시적 타입 변환을 보여준다.
```c
double calc1 = 5 + 3.14;
double calc2 = 5.0f + 3.14;

printf("calc1 : %f\n", calc1);
printf("calc2 : %f\n", calc2);
```
```
calc1 : 8.140000
calc2 : 8.140000
```
위의 코드에서 첫 번째 연산은 int형 데이터와 double형 데이터의 산술 연산이다.   
따라서 데이터의 손실이 최소화되도록 int형 데이터가 double형 데이터로 자동 타입 변환된다.  
두 번째 연산은 float형 데이터와 double형 데이터의 산술 연산이다.  
위와 마찬가지로 데이터의 손실이 최소화되도록 float형 데이터가 double형 데이터로 자동 타입 변환된다.

이렇게 **컴파일러가 자동으로 수행하는 타입 변환은 언제나 데이터의 손실이 최소화되는 방향으로 이루어진다.**  
따라서 C 컴파일러는 다음과 같은 순서대로 자동 타입 변환을 수행하게 된다.

char 형 -> short 형 -> int 형 -> float 형 -> double 형 -> long double 형

## 4.9. 명시적 타입 변환
명시적 타입 변환은 사용자가 타입 캐스트(type cast) 연산자를 사용하여 강제적으로 수행하는 타입 변환을 가리킨다.  
변환하고자 하는 데이터의 앞에 괄호(())를 추가하고, 그 안에 변환할 타입을 적으면 된다. 
C 언어에서는 이 괄호(())를 타입 캐스트(type cast) 연산자라고 한다.  

다음 코드는 명시적 타입 변환을 보여준다.
```c
int num1 = 1;
int num2 = 4;

double calc1 = num1 / num2;
double calc2 = (double) num1 / num2;

printf("calc1 : %f\n", calc1);
printf("calc2 : %f\n", calc2);
```
```
calc1 : 0.000000
calc2 : 0.250000
```
위의 코드에서 첫 번째 연산의 결괏값은 0.000000으로 출력된다.  
그 이유는 산술 연산에 대한 결괏값의 타입은 피연산자의 타입과 언제나 일치하기 때문이다.  
즉 int형 데이터끼리의 산술 연산에 대한 결괏값은 언제나 int형 데이터로 나온다.   
따라서 두 번째 연산에서처럼 하나의 피연산자를 명시적으로 double형으로 지정해야만 정확한 결괏값을 얻을 수 있다.

# 5. 연산자
연산자(operator)란 프로그램의 산술식이나 연산식을 표현하고 처리하기 위해 제공되는 다양한 기호를 의미한다.   
C 언어에서는 여러 종류의 연산을 위해 다양한 연산자를 제공하고 있다.

## 5.1. 산술 연산자
산술 연산자는 사칙연산을 다루는 기본적이면서도 가장 많이 사용되는 연산자이다.   
산술 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.

|산술 연산자|설명|
|------|---|
|+|왼쪽의 피연산자에 오른쪽의 피연산자를 더함|
|-|왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌|
|*|왼쪽의 피연산자에 오른쪽의 피연산자를 곱함|
|/|왼쪽의 피연산자를 오른쪽의 피연산자로 나눔|
|%|왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함.|

```c
int num1 = 10;
int num2 = 4;

printf("+ : %d\n", num1 + num2);
printf("- : %d\n", num1 - num2);
printf("* : %d\n", num1 * num2);
printf("/ : %d\n", num1 / num2);
printf("% : %d\n", num1 % num2);
```
```
+ : 14
- : 6
* : 40
/ : 2
% : 2
```

## 5.2. 대입 연산자
대입 연산자는 변수에 값을 대입할 때 사용하는 이항 연산자이며, 피연산자들의 결합 방향은 오른쪽에서 왼쪽이다.  
또한, 앞서 살펴본 산술 연산자와 결합한 다양한 복합 대입 연산자가 존재한다.

|대입 연산자|설명|
|------|---|
|=|왼쪽의 피연산자에 오른쪽의 피연산자를 대입함.|
|+=|왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.|
|-=|왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결괏값을 왼쪽의 피연산자에 대입함.|
|*=|왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.|
|/=|왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 결괏값을 왼쪽의 피연산자에 대입함.|
|%=|왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입함.|

```c
int num1 = 7;
int num2 = 7;
int num3 = 7;

num1 = num1 - 5;
num2 -= 5;
num3 =- 5;

printf("- : %d\n", num1);
printf("-= : %d\n", num2);
printf("=- : %d\n", num3);
```
```
- : 2
-= : 2
=- : -5
```

> 위의 코드에서 ```num3 =- 5``` 연산은 단순히 -5를 변수 num3에 대입(=)하는 연산이 되었다. 
이처럼 복합 대입 연산자에서 연산자의 순서는 매우 중요하므로 주의를 기울여야 한다.

## 5.3. 증감 연산자
증감 연산자는 피연산자를 1씩 증가 혹은 1씩 감소시킬 때 사용하는 연산자이다. 
이 연산자는 피연산자가 단 하나뿐인 단항 연산자이다.   

증감 연산자는 해당 연산자가 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서 및 결과가 달라진다.

|증감 연산자|설명|
|------|---|
|++x|먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 진행함.|
|x++|먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴.|
|--x|먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 진행함.|
|x--|먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴.|

```c
int num1 = 7;
int num2 = 7;
int calc1, calc2;

calc1 = (++num1) - 5;
calc2 = (num2++) - 5;

printf("calc1 : %d / num1 : %d\n", calc1, num1);
printf("calc2 : %d / num2 : %d\n", calc2, num2);
```
```
calc1 : 3 / num1 : 8
calc2 : 2 / num2 : 8
```
위의 코드에서 첫 번째 연산은 변수 num1의 값을 먼저 1 증가시킨 후에 나머지 연산을 수행한다.   
하지만 두 번째 연산에서는 먼저 모든 연산을 마친 후에 변수 num2의 값을 1 증가시킨다. 
따라서 변수 num2의 증가는 관련된 연산에 아무런 영향도 미치지 않는다. 

## 5.4. 비교 연산자
비교 연산자는 피연산자 사이의 상대적인 크기를 판단하는 연산자이다.   
비교 연산자는 왼쪽의 피연산자와 오른쪽의 피연산자를 비교하여, 어느 쪽이 더 큰지, 작은지, 또는 서로 같은지를 판단한다.   
비교 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.

|비교 연산자|설명|
|------|---|
|==|왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 1을 반환함.|
|!=|왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 1을 반환함.|
|>|왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 1을 반환함.|
|>=|왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 1을 반환함.|
|<|왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 1을 반환함.|
|<=|왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 1을 반환함.|

> C 언어에서 거짓(false)은 0이며, 0이 아닌 모든 것은 참(true)으로 인식된다.

```c
int num1 = 3;
int num2 = 7;

printf("== : %d\n", num1 == num2);
printf("<= : %d\n", num1 <>= num2);
```
```
== : 0
<= : 1
```

## 5.5. 논리 연산자
논리 연산자는 주어진 논리식을 판단하여, 참(true)과 거짓(false)을 결정하는 연산자이다.  
AND 연산과 OR 연산은 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.  
NOT 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽이다.

|논리 연산자|설명|
|------|---|
|&&|논리식이 모두 참이면 1을 반환함. (논리 AND 연산)|
|\|\||논리식 중에서 하나라도 참이면 1을 반환함. (논리 OR 연산)|
|!|논리식의 결과가 참이면 0을, 거짓이면 1을 반환함. (논리 NOT 연산)|

```c
int num1 = 3;
int num2 = -7;
int calc1, calc2;

calc1 = (num1 > 0) && (num1 < 5);
calc2 = (num2 < 0) || (num2 > 10);

printf("&& : %d\n", calc1);
printf("|| : %d\n", calc2);
printf("! : %d\n", !calc2);
```
```
&& : 1
|| : 1
! : 0
```

# 6. 함수
**프로그래밍에서 함수(function)란 하나의 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 프로그램 코드의 집합으로 정의할 수 있다.**  
**C 프로그램은 이러한 함수들로 구성**되며, 포함된 함수들을 사용하여 프로그램의 목적을 달성하게 된다.

C 언어에서 함수는 크게 표준 함수와 사용자 정의 함수로 구분할 수 있다.

## 6.1. 함수의 원형 선언
C 언어에서 함수를 정의할 때는 그 위치가 매우 중요하다.
```c
#include <stdio.h>

int main(void) 
{
   int calc;

   calc = bigNum(3, 5);
   printf("calc : %d\n", calc);
   calc = bigNum(3, 1);
   printf("calc : %d\n", calc);
   calc = bigNum(7, 5);
   printf("calc : %d\n", calc);
   return 0;
}

int bigNum(int num1, int num2) 
{
   if(num1 >= num2)
   {
      return num1;
   }
   else
   {
      return num2;
   }
}
```
C 언어에서는 가장 먼저 main() 함수가 컴파일러에 의해 컴파일된다.

위의 코드에서 컴파일러는 main() 함수에 등장하는 bigNum() 함수를 아직 알지 못하기 때문에 컴파일 오류를 발생시킨다.    
따라서 컴파일러에 bigNum() 함수는 나중에 정의되어 있다고 알려줘야 한다.    
그 역할을 하는 것이 바로 함수의 원형(prototype) 선언이다.

위와 같이 차례대로 한 번에 컴파일하는 방식을 단일 패스(one pass) 컴파일 방식이라고 한다.  
하지만 하드웨어의 발달로 컴파일러에 따라 여러 번에 걸쳐 컴파일하는 다중 패스(multi-pass) 방식이 많아지고 있다.    
다중 패스 방식의 컴파일러에서는 함수의 원형을 선언하지 않아도 컴파일 오류를 발생시키지 않는다.  
하지만 오래된 컴파일러는 대부분 단일 패스 방식으로 컴파일하므로, C 표준에서는 여전히 함수의 원형을 정의하고 있다.

함수의 원형 선언은 다음과 같은 방식으로 선언된다.
```c
반환타입 함수이름(매개변수타입);
```
다음 예제는 앞서 살펴본 예제에 함수의 원형 선언을 추가한 예제이다.   
이렇게 함수의 원형은 main() 함수 앞에 미리 선언되어야 한다.    
```c
#include <stdio.h>
int bigNum(int, int);

int main(void)
{
   int calc;

   calc = bigNum(3, 5);
   printf("calc : %d\n", calc);
   calc = bigNum(3, 1);
   printf("calc : %d\n", calc);
   calc = bigNum(7, 5);
   printf("calc : %d\n", calc);
   return 0;
}

int bigNum(int num1, int num2) 
{
   if(num1 >= num2)
   {
      return num1;
   }
   else 
   {
      return num2;
   }
}
```
```
calc : 5
calc : 3
calc : 7
```

## 6.2. 변수의 유효 범위
C 언어에서는 변수의 선언 위치에 따라 해당 변수의 유효 범위, 메모리 반환 시기, 초기화 여부, 저장되는 장소 등이 변경된다.    
C 언어에서 변수는 위와 같은 특징들을 기준으로 다음과 같이 나눌 수 있다.

1. 지역 변수(local variable)
2. 전역 변수(global variable)
3. 정적 변수(static variable)
4. 레지스터 변수(register variable)

### 메모리의 구조
컴퓨터의 운영체제는 프로그램의 실행을 위해 다양한 메모리 공간을 제공한다.     
C 프로그램이 운영체제로부터 할당받는 대표적인 메모리 공간은 다음과 같다.

1. 코드(code) 영역
2. 데이터(data) 영역
3. 스택(stack) 영역
4. 힙(heap) 영역

메모리의 구조에 대한 더 자세한 사항은 C 언어 메모리의 구조 수업에서 확인할 수 있다.

### 지역 변수
지역 변수란 '블록' 내에서 선언된 변수를 의미한다.  
지역 변수는 변수가 선언된 블록 내에서만 유효하며, 블록이 종료되면 메모리에서 사라진다.

이러한 지역 변수는 메모리상의 스택(stack) 영역에 저장되며, 초기화하지 않으면 의미 없는 값(쓰레기값)으로 초기화된다.  
함수의 매개변수 또한 함수 내에서 정의되는 지역 변수로 취급된다.
```c
#include <stdio.h>
void local(void);

int main(void)
{
    int num = 10;
    printf("num in main() : %d\n", num);

    if (1)
    {
        local();
        int num = 30;
        printf("num in if : %d\n", num);
    }

    printf("num : %d\n", num);
    return 0;
}

void local(void)
{
    int num = 20;
    printf("num in local() : %d\n", num);
}
```
```
num in main() : 10
num in local() : 20
num in if : 30
num : 10
```
위의 코드에서 변수 num은 한 번은 main() 함수 내에서, 또 한 번은 if 문에서, 마지막은 local() 함수 내에서 선언된다.    
이처럼 같은 이름의 변수 num은 모두 다른 중괄호({}) 영역에서 선언되었으며, 이러한 중괄호 영역을 블록(block)이라고 한다.  
이렇게 변수의 유효 범위는 변수가 선언된 블록을 기주으로 설정되며, 해당 블록이 끝나면 모든 지역 변수는 메모리에서 사라지게 된다.  

### 전역 변수
전역 변수란 함수의 외부에서 선언된 변수를 의미한다.   
전역 변수는 프로그램의 어디에서나 접근할 수 있으며, 프로그램이 종료되어야만 메모리에서 사라진다.

이러한 전역 변수는 메모리상의 데이터(data) 영역에 저장되며, 직접 초기화하지 않아도 0으로 자동 초기화된다.
```c
#include <stdio.h>
void local(void);
int num;

int main(void)
{
   printf("num in global : %d\n", num);
   int num = 10;
   printf("num in main() : %d\n", num);
   
   if(1)
   {
      local();
      printf("num in if : %d\n", num);
   }

   return 0;
}

void local(void)
{
   num = 20;
   printf("num in local() : %d\n", num);
}
```
```
num in global : 0
num in main() : 10
num in local() : 20
num in if : 10
```
위의 코드에서 전역 변수 num과 같은 이름의 지역 변수 num이 main() 함수 내부에서 선언된다.     
이 지역 변수가 선언되기 전까지는 main() 함수에서도 전역 변수 num에 접근할 수 있다.  
하지만 지역 변수 num가 선언된 후에는 main() 함수에서 전역 변수 num으로 접근할 방법이 없어진다.  
왜냐하면, 블록 내에서 선언된 지역 변수는 같은 이름의 전역 변수를 덮어쓰기 때문이다.    
따라서 이처럼 전역 변수와 같은 이름으로 지역 변수를 선언하는 것은 좋지 않다.

또한, 여러 개의 파일로 구성된 프로그램에서 외부 파일의 전역 변수를 사용하기 위해서는 extern 키워드를 사용해 다시 선언해야 줘야한다.

### 정적 변수
C 언어에서 정적 변수란 static 키워드로 선언한 변수를 의미한다.    
이렇게 선언된 정적 변수는 지역 변수와 전역 변수의 특징을 모두 가지게 된다.    
함수 내에서 선언된 정적 변수는 전역 변수처럼 단 한 번만 초기화되며(초기화는 최초 실행 시 단 한번만 수행됨), 프로그램이 종료되어야 메모리상에서 사라진다.    
또한, 이렇게 선언된 정적 변수는 지역 변수처럼 해당 함수 내에서만 접근할 수 있다.
```c
#include <stdio.h>
void local(void);
void staticNum(void);

int main(void)
{
   int i;
   for(i = 0; i < 3; i++)
   {
      local();
      staticNum();
   }
   return 0;
}

void local(void)
{
   int count = 1;
   printf("num in local() : %d\n", count);
   count++;
}

void staticNum(void)
{
   static int static_count = 1;
   printf("num in staticNum() : %d\n", static_count);
   static_count++;
}
```
```
num in local() : 1
num in staticNum() : 1
num in local() : 1
num in staticNum() : 2
num in local() : 1
num in staticNum() : 3
```
위의 코드는 지역 변수로 선언된 count와 정적 변수로 선언된 static_count를 서로 비교하는 코드이다.   
지역 변수인 count는 함수의 호출이 끝날 때마다 메모리상에서 사라진다.    
하지만 정적 변수인 static_count는 함수의 호출이 끝나도 메모리상에서 사라지지 않고, 다음 함수 호출 때 이전의 데이터를 그대로 가지고 있다.

정적 변수 static_count의 초기화를 수행하는 ```static int static_count = 1;``` 코드는 최초로 실행될 때 단 한 번만 수행되며, 두 번째부터는 수행되지 않는다.   
또한, static_count는 전역 변수와는 달리 자신이 선언된 staticNum() 함수 이외의 영역에서는 호출할 수 없다.

### 레지스터 변수
레지스터 변수란 지역 변수를 선언할 때 register 키워드를 붙여 선언한 변수를 의미한다.   
이렇게 선언된 레지스터 변수는 CPU의 레지스터(register) 메모리에 저장되어 빠르게 접근할 수 있게 된다.

하지만 컴퓨터의 레지스터는 매우 작은 크기의 메모리이므로, 이 영역에 변수를 선언하기 힘든 경우도 많다.    
그럴 때 C 컴파일러는 해당 변수를 그냥 지역변수로 선언하게 된다.

### 변수의 종류
|변수 종류|키워드|선언 위치|유효 범위|
|------|---|---|---|
|지역 변수|auto|함수/블록의 내부|함수/블록의 내부|
|전역 변수|extern|함수의 외부|프로그램 전체|
|정적 변수|static|함수/블록의 내부|함수/블록의 내부|
|레지스터 변수|register|함수/블록의 내부|함수/블록의 내부|

|변수 종류|메모리 소멸 시기|초깃값|저장 장소|
|------|---|---|---|
|지역 변수|함수 종료시|초기화되지 않음.|스택(stack) 영역|
|전역 변수|프로그램 종료시|0으로 초기화됨.|데이터(data) 영역|
|정적 변수|프로그램 종료시|0으로 초기화됨.|데이터(data) 영역|
|레지스터 변수|함수 종료시|초기화되지 않음.|CPU의 레지스터(register)|

## 6.3. 재귀 호출
함수란 하나의 작업을 수행하기 위해 독립적으로 설계된 프로그램 코드의 집합이다.   
C 프로그램은 이러한 함수들로 구성되며, 포함된 함수들을 사용하여 프로그램의 목적을 달성하게 된다.

재귀 호출(recursive call)이란 함수 내부에서 함수가 자기 자신을 또다시 호출하는 행위를 의미한다.    
이러한 재귀 호출은 자기가 자신을 계속해서 호출하므로, 끝없이 반복되게 된다.   
따라서 함수 내에 재귀 호출을 중단하도록 조건이 변경될 명령문을 반드시 포함해야 한다.
```c
int sum(int n)
{
   int i;
   int result = 0;

   for(i = 1; i <= n; i++)
   {
      result += i;
   }

   return result;
}
```
위의 코드에서 sum() 함수는 재귀 호출을 사용하지 않고 만든 함수이다.  

우선 1부터 4까지의 합을 구하는 알고리즘은 다음과 같다.

1. 1부터 4까지의 합은 1부터 3까지의 합에 4를 더하면 된다.
2. 1부터 3까지의 합은 1부터 2까지의 합에 3을 더하면 된다.
1. 1부터 2까지의 합은 1부터 1까지의 합에 2를 더하면 된다.
1. 1부터 1까지의 합은 그냥 1이다.

위와 같이 논리적인 재귀 알고리즘을 구상하고 나면, 그것을 토대로 의사 코드를 작성할 수 있다.  
위의 알고리즘을 의사 코드(pseudo code)로 작성하면 다음과 같다.
```
시작
   1. n이 1이 아니면, 1부터 (n-1)까지의 합에 n을 더한 값을 반환함.
   2. n이 1이면, 그냥 1을 반환함.
끝
```
이렇게 작성된 의사 코드는 재귀 호출을 이용해 다음 예제와 같이 바로 구현할 수 있게 된다.
```c
int rSum(int n)
{
   if(n == 1)
   {
      return 1;
   }
   return n + rSum(n-1);
}
```
위의 코드에서 if 문이 존재하지 않으면, 이 프로그램은 실행 직후 스택 오버플로우(stack overflow)에 의해 종료될 것이다.    
따라서 if 문처럼 재귀 호출을 중단하기 위한 조건문을 반드시 포함해야 한다.

> 스택 오버플로우(stack overflow)는 메모리 구조 중 스택(stack) 영역에서 해당 프로그램이 사용할 수 있는 메모리 공간 이상을 사용하려고 할 때 발생한다.

이처럼 재귀 호출은 다양한 알고리즘을 표현한 의사 코드를 그대로 코드로 옮길 수 있게 해준다.   
따라서 재귀 호출은 직관적인 프로그래밍을 하는 데 많은 도움을 준다.

하지만 이러한 재귀 호출은 비재귀 호출보다 실행 시간이 오래 걸리는 단점을 가지고 있다.

> 재귀호출의 장점 : 코드의 간결함   
재귀 호출의 단점 : 무한 재귀호출의 위험성, 성능 상의 문제